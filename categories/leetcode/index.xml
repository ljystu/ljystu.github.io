<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Leetcode - Category - My New Hugo Site</title>
        <link>https://github.com/ljystu/ljystu.github.io/categories/leetcode/</link>
        <description>Leetcode - Category - My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ljystu@gmail.com (Jingyu Li)</managingEditor>
            <webMaster>ljystu@gmail.com (Jingyu Li)</webMaster><lastBuildDate>Tue, 17 May 2022 10:36:32 &#43;0100</lastBuildDate><atom:link href="https://github.com/ljystu/ljystu.github.io/categories/leetcode/" rel="self" type="application/rss+xml" /><item>
    <title>Best Time to Buy and Sell Stock</title>
    <link>https://github.com/ljystu/ljystu.github.io/best-time-to-buy-and-sell-stock/</link>
    <pubDate>Tue, 17 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/best-time-to-buy-and-sell-stock/</guid>
    <description><![CDATA[Redis Redis with pyrhon Simple example of how to use redis as Cache in python:
If we want to store some info in cache(logo, name), we first can convert them into JSON format and assign a key, and store the info in cache.
1 2 3  logo = get_logo() #maybe get logo from api json.dumps(logo) #convert to JSON logo_key = f&#34;{symbol}_logo&#34; #naming convention   When we need to use the info, we can first get it from the cache.]]></description>
</item><item>
    <title>Restore IP address</title>
    <link>https://github.com/ljystu/ljystu.github.io/restore-ip-address/</link>
    <pubDate>Sat, 07 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/restore-ip-address/</guid>
    <description><![CDATA[Leetcode 93 https://leetcode-cn.com/problems/restore-ip-addresses/ A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. For example, &ldquo;0.1.2.201&rdquo; and &ldquo;192.168.1.1&rdquo; are valid IP addresses, but &ldquo;0.011.255.245&rdquo;, &ldquo;192.168.1.312&rdquo; and &ldquo;192.168@1.1&rdquo; are invalid IP addresses. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You]]></description>
</item><item>
    <title>backtracking summary</title>
    <link>https://github.com/ljystu/ljystu.github.io/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/</link>
    <pubDate>Fri, 06 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N]]></description>
</item><item>
    <title>Permutations II</title>
    <link>https://github.com/ljystu/ljystu.github.io/permutations-ii/</link>
    <pubDate>Fri, 06 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/permutations-ii/</guid>
    <description><![CDATA[Leetcode 47 https://leetcode-cn.com/problems/permutations-ii/ Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Constraints: 1 &lt;= nums.length &lt;= 8 -10 &lt;= nums[i] &lt;= 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]]></description>
</item><item>
    <title>Validate Binary Search Tree</title>
    <link>https://github.com/ljystu/ljystu.github.io/validate-binary-search-tree/</link>
    <pubDate>Tue, 03 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/validate-binary-search-tree/</guid>
    <description><![CDATA[Leetcode 98 https://leetcode-cn.com/problems/validate-binary-search-tree/ Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node&rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&rsquo;s key. Both the left and right subtrees must also be binary search]]></description>
</item><item>
    <title>Construct Tree</title>
    <link>https://github.com/ljystu/ljystu.github.io/construct-tree/</link>
    <pubDate>Mon, 02 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/construct-tree/</guid>
    <description><![CDATA[Leetcode 106 105 https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ Example 1: Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7] Example 2: Input: inorder = [-1], postorder = [-1] Output: [-1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //Recursion 106 class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { return Traverse(inorder,]]></description>
</item><item>
    <title>Invert Binary Tree</title>
    <link>https://github.com/ljystu/ljystu.github.io/invert-binary-tree/</link>
    <pubDate>Mon, 02 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/invert-binary-tree/</guid>
    <description><![CDATA[https://leetcode-cn.com/problems/invert-binary-tree/ Given the root of a binary tree, invert the tree, and return its root.
 Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1]
Example 2: Input: root = [2,1,3] Output: [2,3,1]
Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 &lt;= Node.val &lt;= 100
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  //Iteration /** * Definition for a binary tree node.]]></description>
</item><item>
    <title>BFS</title>
    <link>https://github.com/ljystu/ljystu.github.io/bfs/</link>
    <pubDate>Sun, 01 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/bfs/</guid>
    <description><![CDATA[Leetcode 102 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ Given the root of a binary tree, return the level order traversal of its nodes&rsquo; values. (i.e., from left to right, level by level).
 Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]]
Example 2: Input: root = [1] Output: [[1]]
Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 2000]. -1000 &lt;= Node.val &lt;= 1000]]></description>
</item><item>
    <title>Compare Tree</title>
    <link>https://github.com/ljystu/ljystu.github.io/compare-tree/</link>
    <pubDate>Sun, 01 May 2022 10:36:32 &#43;0100</pubDate><author>
        <name>Jingyu Li</name>
    </author><guid>https://github.com/ljystu/ljystu.github.io/compare-tree/</guid>
    <description><![CDATA[leetcode 100 https://leetcode-cn.com/problems/same-tree/
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  //DFS /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.]]></description>
</item></channel>
</rss>
